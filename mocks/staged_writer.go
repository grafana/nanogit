// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/grafana/nanogit"
	"github.com/grafana/nanogit/protocol/hash"
)

type FakeStagedWriter struct {
	CommitStub        func(context.Context, string, nanogit.Author, nanogit.Committer) (*nanogit.Commit, error)
	commitMutex       sync.RWMutex
	commitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 nanogit.Author
		arg4 nanogit.Committer
	}
	commitReturns struct {
		result1 *nanogit.Commit
		result2 error
	}
	commitReturnsOnCall map[int]struct {
		result1 *nanogit.Commit
		result2 error
	}
	CreateBlobStub        func(context.Context, string, []byte) (hash.Hash, error)
	createBlobMutex       sync.RWMutex
	createBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}
	createBlobReturns struct {
		result1 hash.Hash
		result2 error
	}
	createBlobReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	DeleteBlobStub        func(context.Context, string) (hash.Hash, error)
	deleteBlobMutex       sync.RWMutex
	deleteBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteBlobReturns struct {
		result1 hash.Hash
		result2 error
	}
	deleteBlobReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	DeleteTreeStub        func(context.Context, string) (hash.Hash, error)
	deleteTreeMutex       sync.RWMutex
	deleteTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteTreeReturns struct {
		result1 hash.Hash
		result2 error
	}
	deleteTreeReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	PushStub        func(context.Context) error
	pushMutex       sync.RWMutex
	pushArgsForCall []struct {
		arg1 context.Context
	}
	pushReturns struct {
		result1 error
	}
	pushReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateBlobStub        func(context.Context, string, []byte) (hash.Hash, error)
	updateBlobMutex       sync.RWMutex
	updateBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}
	updateBlobReturns struct {
		result1 hash.Hash
		result2 error
	}
	updateBlobReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStagedWriter) Commit(arg1 context.Context, arg2 string, arg3 nanogit.Author, arg4 nanogit.Committer) (*nanogit.Commit, error) {
	fake.commitMutex.Lock()
	ret, specificReturn := fake.commitReturnsOnCall[len(fake.commitArgsForCall)]
	fake.commitArgsForCall = append(fake.commitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 nanogit.Author
		arg4 nanogit.Committer
	}{arg1, arg2, arg3, arg4})
	stub := fake.CommitStub
	fakeReturns := fake.commitReturns
	fake.recordInvocation("Commit", []interface{}{arg1, arg2, arg3, arg4})
	fake.commitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) CommitCallCount() int {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	return len(fake.commitArgsForCall)
}

func (fake *FakeStagedWriter) CommitCalls(stub func(context.Context, string, nanogit.Author, nanogit.Committer) (*nanogit.Commit, error)) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = stub
}

func (fake *FakeStagedWriter) CommitArgsForCall(i int) (context.Context, string, nanogit.Author, nanogit.Committer) {
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	argsForCall := fake.commitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStagedWriter) CommitReturns(result1 *nanogit.Commit, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	fake.commitReturns = struct {
		result1 *nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) CommitReturnsOnCall(i int, result1 *nanogit.Commit, result2 error) {
	fake.commitMutex.Lock()
	defer fake.commitMutex.Unlock()
	fake.CommitStub = nil
	if fake.commitReturnsOnCall == nil {
		fake.commitReturnsOnCall = make(map[int]struct {
			result1 *nanogit.Commit
			result2 error
		})
	}
	fake.commitReturnsOnCall[i] = struct {
		result1 *nanogit.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) CreateBlob(arg1 context.Context, arg2 string, arg3 []byte) (hash.Hash, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createBlobMutex.Lock()
	ret, specificReturn := fake.createBlobReturnsOnCall[len(fake.createBlobArgsForCall)]
	fake.createBlobArgsForCall = append(fake.createBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.CreateBlobStub
	fakeReturns := fake.createBlobReturns
	fake.recordInvocation("CreateBlob", []interface{}{arg1, arg2, arg3Copy})
	fake.createBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) CreateBlobCallCount() int {
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	return len(fake.createBlobArgsForCall)
}

func (fake *FakeStagedWriter) CreateBlobCalls(stub func(context.Context, string, []byte) (hash.Hash, error)) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = stub
}

func (fake *FakeStagedWriter) CreateBlobArgsForCall(i int) (context.Context, string, []byte) {
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	argsForCall := fake.createBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStagedWriter) CreateBlobReturns(result1 hash.Hash, result2 error) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = nil
	fake.createBlobReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) CreateBlobReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = nil
	if fake.createBlobReturnsOnCall == nil {
		fake.createBlobReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.createBlobReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteBlob(arg1 context.Context, arg2 string) (hash.Hash, error) {
	fake.deleteBlobMutex.Lock()
	ret, specificReturn := fake.deleteBlobReturnsOnCall[len(fake.deleteBlobArgsForCall)]
	fake.deleteBlobArgsForCall = append(fake.deleteBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteBlobStub
	fakeReturns := fake.deleteBlobReturns
	fake.recordInvocation("DeleteBlob", []interface{}{arg1, arg2})
	fake.deleteBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) DeleteBlobCallCount() int {
	fake.deleteBlobMutex.RLock()
	defer fake.deleteBlobMutex.RUnlock()
	return len(fake.deleteBlobArgsForCall)
}

func (fake *FakeStagedWriter) DeleteBlobCalls(stub func(context.Context, string) (hash.Hash, error)) {
	fake.deleteBlobMutex.Lock()
	defer fake.deleteBlobMutex.Unlock()
	fake.DeleteBlobStub = stub
}

func (fake *FakeStagedWriter) DeleteBlobArgsForCall(i int) (context.Context, string) {
	fake.deleteBlobMutex.RLock()
	defer fake.deleteBlobMutex.RUnlock()
	argsForCall := fake.deleteBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStagedWriter) DeleteBlobReturns(result1 hash.Hash, result2 error) {
	fake.deleteBlobMutex.Lock()
	defer fake.deleteBlobMutex.Unlock()
	fake.DeleteBlobStub = nil
	fake.deleteBlobReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteBlobReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.deleteBlobMutex.Lock()
	defer fake.deleteBlobMutex.Unlock()
	fake.DeleteBlobStub = nil
	if fake.deleteBlobReturnsOnCall == nil {
		fake.deleteBlobReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.deleteBlobReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteTree(arg1 context.Context, arg2 string) (hash.Hash, error) {
	fake.deleteTreeMutex.Lock()
	ret, specificReturn := fake.deleteTreeReturnsOnCall[len(fake.deleteTreeArgsForCall)]
	fake.deleteTreeArgsForCall = append(fake.deleteTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteTreeStub
	fakeReturns := fake.deleteTreeReturns
	fake.recordInvocation("DeleteTree", []interface{}{arg1, arg2})
	fake.deleteTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) DeleteTreeCallCount() int {
	fake.deleteTreeMutex.RLock()
	defer fake.deleteTreeMutex.RUnlock()
	return len(fake.deleteTreeArgsForCall)
}

func (fake *FakeStagedWriter) DeleteTreeCalls(stub func(context.Context, string) (hash.Hash, error)) {
	fake.deleteTreeMutex.Lock()
	defer fake.deleteTreeMutex.Unlock()
	fake.DeleteTreeStub = stub
}

func (fake *FakeStagedWriter) DeleteTreeArgsForCall(i int) (context.Context, string) {
	fake.deleteTreeMutex.RLock()
	defer fake.deleteTreeMutex.RUnlock()
	argsForCall := fake.deleteTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStagedWriter) DeleteTreeReturns(result1 hash.Hash, result2 error) {
	fake.deleteTreeMutex.Lock()
	defer fake.deleteTreeMutex.Unlock()
	fake.DeleteTreeStub = nil
	fake.deleteTreeReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) DeleteTreeReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.deleteTreeMutex.Lock()
	defer fake.deleteTreeMutex.Unlock()
	fake.DeleteTreeStub = nil
	if fake.deleteTreeReturnsOnCall == nil {
		fake.deleteTreeReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.deleteTreeReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) Push(arg1 context.Context) error {
	fake.pushMutex.Lock()
	ret, specificReturn := fake.pushReturnsOnCall[len(fake.pushArgsForCall)]
	fake.pushArgsForCall = append(fake.pushArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.PushStub
	fakeReturns := fake.pushReturns
	fake.recordInvocation("Push", []interface{}{arg1})
	fake.pushMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStagedWriter) PushCallCount() int {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	return len(fake.pushArgsForCall)
}

func (fake *FakeStagedWriter) PushCalls(stub func(context.Context) error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = stub
}

func (fake *FakeStagedWriter) PushArgsForCall(i int) context.Context {
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	argsForCall := fake.pushArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStagedWriter) PushReturns(result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	fake.pushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStagedWriter) PushReturnsOnCall(i int, result1 error) {
	fake.pushMutex.Lock()
	defer fake.pushMutex.Unlock()
	fake.PushStub = nil
	if fake.pushReturnsOnCall == nil {
		fake.pushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStagedWriter) UpdateBlob(arg1 context.Context, arg2 string, arg3 []byte) (hash.Hash, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.updateBlobMutex.Lock()
	ret, specificReturn := fake.updateBlobReturnsOnCall[len(fake.updateBlobArgsForCall)]
	fake.updateBlobArgsForCall = append(fake.updateBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.UpdateBlobStub
	fakeReturns := fake.updateBlobReturns
	fake.recordInvocation("UpdateBlob", []interface{}{arg1, arg2, arg3Copy})
	fake.updateBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStagedWriter) UpdateBlobCallCount() int {
	fake.updateBlobMutex.RLock()
	defer fake.updateBlobMutex.RUnlock()
	return len(fake.updateBlobArgsForCall)
}

func (fake *FakeStagedWriter) UpdateBlobCalls(stub func(context.Context, string, []byte) (hash.Hash, error)) {
	fake.updateBlobMutex.Lock()
	defer fake.updateBlobMutex.Unlock()
	fake.UpdateBlobStub = stub
}

func (fake *FakeStagedWriter) UpdateBlobArgsForCall(i int) (context.Context, string, []byte) {
	fake.updateBlobMutex.RLock()
	defer fake.updateBlobMutex.RUnlock()
	argsForCall := fake.updateBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStagedWriter) UpdateBlobReturns(result1 hash.Hash, result2 error) {
	fake.updateBlobMutex.Lock()
	defer fake.updateBlobMutex.Unlock()
	fake.UpdateBlobStub = nil
	fake.updateBlobReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) UpdateBlobReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.updateBlobMutex.Lock()
	defer fake.updateBlobMutex.Unlock()
	fake.UpdateBlobStub = nil
	if fake.updateBlobReturnsOnCall == nil {
		fake.updateBlobReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.updateBlobReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *FakeStagedWriter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.commitMutex.RLock()
	defer fake.commitMutex.RUnlock()
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	fake.deleteBlobMutex.RLock()
	defer fake.deleteBlobMutex.RUnlock()
	fake.deleteTreeMutex.RLock()
	defer fake.deleteTreeMutex.RUnlock()
	fake.pushMutex.RLock()
	defer fake.pushMutex.RUnlock()
	fake.updateBlobMutex.RLock()
	defer fake.updateBlobMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStagedWriter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ nanogit.StagedWriter = new(FakeStagedWriter)
